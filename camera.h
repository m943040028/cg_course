#ifndef _CAMERA_H_
#define _CAMERA_H_

#include "vectors.h"
#include "ray.h"

#include <float.h>


class Camera {

public:
	Camera() {};
	~Camera() {};
	//
	// Generate a Ray from Camera
	//
	// @point  The origin of the rays generated by the camera 
	//         for the screen coordinates,
	//         which vary from (0,0) -> (1,1)
	//
	// The camera does not know about screen resolution.
	// Image resolution should be handled by the user. 
	// For non-square image ratios,
	// just crop the screen coordinates accordingly.
	virtual Ray generateRay(Vec2f point) = 0;
	virtual float getTMin() const = 0;

private:
};


class OrthographicCamera : public Camera {

public:
	OrthographicCamera(const Vec3f &center, const Vec3f &direction, 
			const Vec3f &up, float size) {
		this->center = center;
		this->direction = direction;
		this->direction.Normalize();
		this->up = up;
		this->up.Normalize();

		this->size = size;

		Vec3f::Cross3(this->horizontal, this->direction, this->up);

		// if up vector is not orthonormal with direction vector,
		// let it be.
		if (!this->direction.Dot3(this->up))
			Vec3f::Cross3(this->up, this->horizontal,
					this->direction);

		// For Orthographic Camera, Ray always started from infinity
		this->tmin = -FLT_MAX;
	}
	~OrthographicCamera() {};
	virtual Ray generateRay(Vec2f point);
	virtual float getTMin() const
	{
		return tmin;
	}

private:
	// Following is a point(location)
	Vec3f center;

	// Following is a vector(offset)
	Vec3f direction;
	Vec3f up;
	Vec3f horizontal;

	float tmin;
	float size;
};

class PerspectiveCamera : public Camera {

public:
	PerspectiveCamera(const Vec3f &center, const Vec3f &direction, 
			const Vec3f &up, float angle_radians) {
		this->center = center;
		this->direction = direction;
		this->direction.Normalize();
		this->up = up;
		this->up.Normalize();

		Vec3f::Cross3(this->horizontal, this->direction, this->up);

		// if up vector is not orthonormal with direction vector,
		// let it be.
		if (!this->direction.Dot3(this->up))
			Vec3f::Cross3(this->up, this->horizontal,
					this->direction);

		// For Perspective Camera, Ray always started from origin
		this->tmin = 0;
		this->angle = angle_radians;
	}
	~PerspectiveCamera() {};
	virtual Ray generateRay(Vec2f point);
	virtual float getTMin() const
	{
		return tmin;
	}

private:
	// Following is a point(location)
	Vec3f center;

	// Following is a vector(offset)
	Vec3f direction;
	Vec3f up;
	Vec3f horizontal;

	float tmin;
	float angle;
};

#endif
